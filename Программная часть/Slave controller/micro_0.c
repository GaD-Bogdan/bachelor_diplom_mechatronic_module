/*
 * Microcontroller_0.c
 *
 * Created: 04.06.2020 11:16:09
 * Author : GaD_Bogdan
 */ 
#include "Libraries/main.h"
//===================================================================================================================
#define MOTOR_SPEED 255
//===================================================================================================================
uint8_t SPI_byte_counter = 0;					// Переменная для счета принятых байтов по SPI
uint8_t stop_flag = 0;							// Переменная, для хранения состояния ДКП
uint8_t motor_dir;								// Флаг, для определения направления вращения двигателя
uint32_t data32;								// Переменная для полученных данных с технологического контроллера
uint32_t encoder_counter = 0;					// Заводим 32-байтовую переменную под счетчик для энкодера.
int32_t delta = 0;								// Переменная для подсчета ошибки
uint8_t * p_data32;								// Указатель на первый байт этих данных
char str_array[12];								// Строковый массив для вывода на LCD дисплей
//===================================================================================================================
void ext_INTERRUPT_init(void);					// Прототип функции, для возможности ее вызова
void device_is_busy(uint8_t is_busy);			// Функция для сообщения технологическому контроллеру о занятости
void motor_driver_init(void);					// Функция инициализации управления драйвером
void motor_driver_start(uint8_t OCR0A_value, uint8_t direction);	// Функция запуска двигателя
void motor_driver_stop(void);					// Функция остановки двигателя
void motor_calibration(void);					// Функция калибровки двигателя
//===================================================================================================================
int main(void)
{
	device_is_busy(1);					// Говорим, что устройство занято инициализацией

 	p_data32 = (uint8_t *) &data32;		// Инициализируем указатель на область памяти с data32
	ext_INTERRUPT_init();				// Инициализация внешних прерываний
	motor_driver_init();				// Инициализация таймера
	sei();								// Разрешаем прерывания
	motor_calibration();				// Калибровка привода
 	SPI_SL_init();						// Инициализируем SPI в качестве ведомого
//	LCD_init();							// Подключаем LCD-дисплей для отладки

  	device_is_busy(0);					// Устройство готово к работе
    while (1) 
    {
//-------------------------------------------------------------------------------------------------------------------
		if (stop_flag)						// Если сработал ДКП, все останавливаем
		{
			motor_driver_stop();			// Если сработал ДКП останавливаем двигатель
			device_is_busy(1);					// Говорим, что устройство занято
			continue;
		}
//-------------------------------------------------------------------------------------------------------------------	
		if (SPI_byte_counter == 4)				// Если закончился прием данных...
		{
			delta = data32 - encoder_counter;	// Высчитываем дельту
			if (delta < 7 && delta > -7)		// Если дельта в пределах погрешности, то
			{
				motor_driver_stop();			// Останавливаем двигатель
				SPI_byte_counter = 0;			// Обнуляем счетчик SPI
				device_is_busy(0);				// Говорим, что устройство готово к обемену
				continue;
			}
			else if (delta > 0)					// Если дельта больше нуля, то...
			{
				motor_driver_start(MOTOR_SPEED, 1);	// Вращаем в положительном направлении
			}
			else								// Если дельта меньше нуля, то...
			{
				motor_driver_start(MOTOR_SPEED, 0);	// Вращаем в отрицательном направлении
			}
		}
	}
}
//===================================================================================================================
ISR(INT0_vect)						// Обработчик внешнего прерывания INT0
{
	stop_flag = 1;					// Устанавливаем флаг остановки привода
}
//===================================================================================================================
ISR(INT1_vect)						// Обработчик внешнего прерывания INT1
{
	if (BitIsSet(PIND, 4)) encoder_counter++;				// Если вторая ножка энкодера в 1, значит прибавляем
	else encoder_counter--;									// Если вторая ножка энкодера в 0, значит отнимаем
	
}
//===================================================================================================================
ISR(SPI_STC_vect)					// Обработчик прерывания по приему байта данных
{
	*(p_data32 + SPI_byte_counter) = SPDR;								// Записываем полученный байт в память
	SPI_byte_counter++;													// Увеличиваем счетчик адреса
	if (SPI_byte_counter == 4) 
	{
		device_is_busy(1);			// Если приняли 4 байта, то приступаем к выполнению движения
	}
}
//===================================================================================================================
void motor_calibration(void)
{
	motor_driver_start(MOTOR_SPEED, 0);		// Запускаем двигатель в обратном направлении
	while(1)
	{
		_delay_us(1);
		if (stop_flag)						// Если сработал ДКП...
		{
			motor_driver_stop();			// Останавливаем двигатель
			stop_flag = 0;					// Возвращаем в 0 флаг остновки
			encoder_counter = 0;			// Калибруем переменную-счетчик импульсов
			break;							// Калибровка завершена
		}
		else								// Если нет, то ждем
		{
			continue;
		}
	}
}
//===================================================================================================================
void motor_driver_init(void)
{
	SetBit(DDRD, 7);												// Ножка драйвера "dir" на выход
	SetBit(DDRD, 6);												// OC0A на выход
	TCCR0A = (0<<COM0A1)|(1<<COM0A0)|(1<<WGM01)|(0<<WGM00);			// Выбираем режим СТС и переключение ножки OC0A при совпадении
}
void motor_driver_start(uint8_t OCR0A_value, uint8_t direction)
{
	if (direction) SetBit(PORTD, 7);								// Если direction = 1, то пин dir в высокое состояние
	else ClearBit(PORTD, 7);										// Иначе в низкое
	OCR0A = OCR0A_value;											// Задаем скорость
	TCCR0B = (1<<CS02)|(0<<CS01)|(1<<CS00);							// Запускаем таймер, предделитель 1024
}
void motor_driver_stop(void)
{
	TCCR0B = (0<<CS02)|(0<<CS01)|(0<<CS00);							// Останавливаем таймер
	TCNT0 = 0;														// Обнуляем счетчик таймера
}
//===================================================================================================================
void device_is_busy(uint8_t is_busy)
{
	if (is_busy)
	{
		SetBit(DDRD, 0);					// Опускаем статус-шину, сообщая, что устройство занято
		ClearBit(PORTD, 0);	
	} 
	else
	{
		ClearBit(DDRD, 0);					// Отпускаем статус-шину, сообщая, что устройство готово к обмену данными
		SetBit(PORTD, 0);					// Подтягиваем ее к 1 через резистор
	}
}
//===================================================================================================================
void ext_INTERRUPT_init(void)					// Инициализация внешних прерываний INT0 и INT1
{
	ClearBit(DDRD, 2);							// Настраиваем ножку с прерыванием по срабатыванию ДКП на вход
	SetBit(PORTD, 2);							// Подтяжка к 1
	EICRA = (1<<ISC01)|(0<<ISC00);				// Прерывание при спадающем фронте на PD2
	SetBit(EIMSK, INT0);						// Разрешаем прерывание INT1
	
	ClearBit(DDRD, 3);							// Настраиваем ножку на вход
	SetBit(PORTD, 3);							// Подтяжка к 1
	EICRA = (1<<ISC11)|(0<<ISC10);				// Прерывание при спадающем фронте на PD3
	SetBit(EIMSK, INT1);						// Разрешаем прерывание INT1
}
//===================================================================================================================

